% INPUT:
% 
% basename:		string containing the path to the XML files generated by TGMM code. For exmaple, if they are located at E:\TGMMruns\GMEMtracking3D_2014_6_3_15_39_21\XML_finalResult_lht, then basename = 'E:\TGMMruns\GMEMtracking3D_2014_6_3_15_39_21\XML_finalResult_lht\GMEMfinalResult_frame'
% frameIni:		integer with the initial time point to import (typically it is 0)
% frameEnd:		integer with the final time point to import
% 
% OUTPUT:
%
% precisionMatrix:  precision matrix for each element
% svIdxCell:		cell array of length N, where N is the total number of objects tracked. svIdxCell{i} contains the indexes of the supervoxels belonging to the i-th object in trackingMatrix array. This index is necessary to rescue the segmentation from the .svb files output by TGMM software. The index starts in 0 following C convention. 
% trackingMatrix:		numericall array of size Nx10, where N is the number of points tracked bt TGMM over time. Each of the columns contains the following information:
% 
% 1.	Unique Id from the database to identify the point ( a large integer number)
% 2.	Cell type (represented by an integer). It is 0 if no cell type has been set for this object.
% 3.	x location of the nucleus centroid in world coordinates. Use the variable stackRes to convert from world coordinates to pixel unites.
% 4.	Same as 3 but for y location.
% 5.	Same as 3 but for z location.
% 6.	Estimated radius of the nucleus. It is 0 if this parameter was not estimated.
% 7.	Id of the cell in the previous time point. It is -1 if there is no linkage. Otherwise it has the unique id of the parent from column 1, so you can reconstruct the lineage.
% 8.	Time point of the nucleus.
% 9.	Confidence level in the tracking result. Value of 3 indicates high confidence that the object was correctly tracked. Value of 0 indicates low confidence.
% 10.	Skeleton id. All cells belonging to the same lineage have the same unique skeleton id.



%Special usages of elements:
%column 2: instead of cell type stores Nk (intensity)
%column 6: instead of radius stores beta_prior (for TGMM is equal to probability of background)
function [trackingMatrix, svIdxCell, precisionMatrix, probCellDivision]= parseMixtureGaussiansXml2trackingMatrixCATMAIDformat(basename,frameIni,frameEnd)





numTM = frameEnd - frameIni + 1;
trackingMatrix = zeros( 15000 * numTM, 10 );%preallocate memory
precisionMatrix = zeros(size(trackingMatrix,1),6);
probCellDivision = zeros(size(trackingMatrix,1),1);
svIdxCell = cell( size(trackingMatrix,1), 1);%stores supervoxel idx for each element in trackingMatrix
trackingMatrixN = 0;
skeletonN = 0;
for frame=frameIni:frameEnd
    
    obj=readXMLmixtureGaussians([basename num2str(frame,'%.4d') '.xml']);        
    
    %process each object
    mapId = zeros(length(obj),1);
    for ii=1:length(obj)
        blob=obj(ii);
        
        if( blob.m(1) < -1e31 )%dead cell
            continue;
        end
        
        if(isempty(blob.splitScore)) 
            blob.splitScore=-1e32;
        end;
        
        trackingMatrixN = trackingMatrixN + 1;
        mapId(ii) = trackingMatrixN;
        
        parId = blob.parent + 1;%matlab indexing        
        if( parId <= 0 || frame == frameIni )
            skeletonN = skeletonN + 1;
            skeletonId = skeletonN;           
            parNodeId = -1;
        else
            parId = mapIdOld( parId );
            skeletonId = trackingMatrix(parId,10);
            parNodeId = trackingMatrix(parId,1);
        end
        
        trackingMatrix(trackingMatrixN,:) = [trackingMatrixN max(blob.alpha-blob.alphaPrior,0) blob.m blob.betaPrior  parNodeId frame  blob.splitScore skeletonId];%used as a wildcard for different measuemrents: betaPrior has probBAckground
        precisionMatrix(trackingMatrixN,:) = blob.nu*[blob.W(1,1) blob.W(1,2) blob.W(1,3) blob.W(2,2) blob.W(2,3) blob.W(3,3)];
        svIdxCell{ trackingMatrixN } = blob.svIdx;       
        probCellDivision(trackingMatrixN) = blob.sigmaDistPrior;
    end              
    mapIdOld = mapId;
end

trackingMatrix = trackingMatrix( 1:trackingMatrixN, : );
precisionMatrix = precisionMatrix( 1:trackingMatrixN, : );
svIdxCell = svIdxCell(1:trackingMatrixN);
probCellDivision = probCellDivision(1:trackingMatrixN);
